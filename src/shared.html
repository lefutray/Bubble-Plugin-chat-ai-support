<style>
/* Chat AI Support Plugin Styles */
.bubble-element .chat-ai-support-container {
    position: relative;
    width: 100%;
    height: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
}

.bubble-element .chat-container {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    overflow: hidden;
    height: 100%;
    display: flex;
    flex-direction: column;
}

/* Chat Header */
.bubble-element .chat-header {
    background: linear-gradient(135deg, var(--theme-color, #667eea) 0%, #764ba2 100%);
    color: white;
    padding: 16px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.bubble-element .chat-title {
    display: flex;
    align-items: center;
    font-weight: 600;
    font-size: 16px;
}

.bubble-element .token-counter {
    font-size: 11px;
    font-weight: 400;
    opacity: 0.8;
    margin-left: 12px;
    background: rgba(255, 255, 255, 0.2);
    padding: 2px 8px;
    border-radius: 10px;
    font-variant-numeric: tabular-nums;
    transition: transform 0.2s ease-out;
}

.bubble-element .status-indicator {
    width: 8px;
    height: 8px;
    background: #48bb78;
    border-radius: 50%;
    margin-right: 10px;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.bubble-element .chat-controls {
    display: flex;
    gap: 8px;
}

.bubble-element .btn-minimize, .bubble-element .btn-close {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: bold;
    transition: background-color 0.2s;
}

.bubble-element .btn-minimize:hover, .bubble-element .btn-close:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* Chat Messages */
.bubble-element .chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.bubble-element .message {
    display: flex;
    gap: 12px;
    max-width: 85%;
}

.bubble-element .user-message {
    align-self: flex-end;
    flex-direction: row-reverse;
}

.bubble-element .message-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    flex-shrink: 0;
}

.bubble-element .ai-message .message-avatar {
    background: linear-gradient(135deg, var(--theme-color, #667eea) 0%, #764ba2 100%);
}

.bubble-element .user-message .message-avatar {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
}

.bubble-element .message-content {
    flex: 1;
}

.bubble-element .message-text {
    background: #f7fafc;
    padding: 12px 16px;
    border-radius: 18px;
    word-wrap: break-word;
    white-space: pre-wrap;
}

.bubble-element .user-message .message-text {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
}

.bubble-element .ai-message .message-text {
    background: #edf2f7;
    border: 1px solid #e2e8f0;
}

.bubble-element .message-time {
    font-size: 11px;
    color: #a0aec0;
    margin-top: 4px;
    text-align: right;
}

.bubble-element .user-message .message-time {
    text-align: left;
}

/* Typing Indicator */
.bubble-element .typing-indicator {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px 20px;
    opacity: 0;
    transition: opacity 0.3s;
}

.bubble-element .typing-indicator.show {
    opacity: 1;
}

.bubble-element .typing-dots {
    display: flex;
    gap: 4px;
}

.bubble-element .typing-dot {
    width: 8px;
    height: 8px;
    background: #cbd5e0;
    border-radius: 50%;
    animation: typing 1.4s infinite;
}

.bubble-element .typing-dot:nth-child(2) { animation-delay: 0.2s; }
.bubble-element .typing-dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes typing {
    0%, 60%, 100% { transform: translateY(0); }
    30% { transform: translateY(-10px); }
}

/* Chat Input */
.bubble-element .chat-input-container {
    border-top: 1px solid #e2e8f0;
    padding: 16px 20px;
    background: #f8fafc;
    flex-shrink: 0;
}

.bubble-element .input-wrapper {
    display: flex;
    align-items: flex-end;
    gap: 12px;
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 24px;
    padding: 8px 16px;
    transition: border-color 0.2s;
}

.bubble-element .input-wrapper:focus-within {
    border-color: var(--theme-color, #667eea);
}

.bubble-element .chat-input {
    flex: 1;
    border: none;
    outline: none;
    resize: none;
    font-size: 14px;
    line-height: 1.5;
    max-height: 120px;
    background: transparent;
    font-family: inherit;
}

.bubble-element .chat-input::placeholder {
    color: #a0aec0;
}

.bubble-element .send-button {
    background: linear-gradient(135deg, var(--theme-color, #667eea) 0%, #764ba2 100%);
    border: none;
    color: white;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s;
    flex-shrink: 0;
}

.bubble-element .send-button:hover {
    transform: scale(1.05);
}

.bubble-element .send-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.bubble-element .input-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    font-size: 12px;
    color: #718096;
}

.bubble-element .char-counter {
    font-variant-numeric: tabular-nums;
}

.bubble-element .upload-button {
    background: transparent;
    border: 1px solid #e2e8f0;
    color: #4a5568;
    padding: 6px 12px;
    border-radius: 16px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
}

.bubble-element .upload-button:hover {
    background: #f7fafc;
    border-color: #cbd5e0;
}

/* Document Panel */
.bubble-element .document-panel {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    overflow: hidden;
    margin-top: 10px;
}

.bubble-element .panel-header {
    background: #f8fafc;
    border-bottom: 1px solid #e2e8f0;
    padding: 16px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.bubble-element .panel-header h3 {
    font-size: 16px;
    font-weight: 600;
    color: #2d3748;
    margin: 0;
}

.bubble-element .toggle-button {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    color: #718096;
    transition: transform 0.3s;
}

.bubble-element .toggle-button.collapsed {
    transform: rotate(-90deg);
}

.bubble-element .panel-content {
    transition: max-height 0.3s ease-out;
    overflow: hidden;
}

.bubble-element .panel-content.collapsed {
    max-height: 0;
}

.bubble-element .document-list {
    padding: 20px;
}

.bubble-element .empty-state {
    text-align: center;
    color: #718096;
    font-size: 14px;
    padding: 40px 20px;
}

.bubble-element .document-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    margin-bottom: 8px;
    transition: all 0.2s;
}

.bubble-element .document-item:hover {
    background: #f7fafc;
    border-color: #cbd5e0;
}

.bubble-element .document-info {
    display: flex;
    align-items: center;
    gap: 12px;
}

.bubble-element .document-icon {
    font-size: 20px;
}

.bubble-element .document-details h4 {
    font-size: 14px;
    font-weight: 500;
    color: #2d3748;
    margin: 0 0 2px 0;
}

.bubble-element .document-details p {
    font-size: 12px;
    color: #718096;
    margin: 0;
}

.bubble-element .document-actions {
    display: flex;
    gap: 8px;
}

.bubble-element .action-btn {
    background: none;
    border: none;
    padding: 6px;
    border-radius: 4px;
    cursor: pointer;
    color: #718096;
    transition: all 0.2s;
}

.bubble-element .action-btn:hover {
    background: #edf2f7;
    color: #4a5568;
}

/* Toast Notifications */
.bubble-element .toast-container {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 8px;
    pointer-events: none;
}

.bubble-element .toast {
    background: white;
    border-left: 4px solid #48bb78;
    border-radius: 8px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    padding: 16px;
    min-width: 300px;
    transform: translateX(100%);
    animation: slideIn 0.3s ease-out forwards;
    pointer-events: auto;
}

.bubble-element .toast.error {
    border-left-color: #f56565;
}

.bubble-element .toast.warning {
    border-left-color: #ed8936;
}

@keyframes slideIn {
    to { transform: translateX(0); }
}

/* Responsive */
@media (max-width: 768px) {
    .bubble-element .chat-messages {
        padding: 15px;
    }
    
    .bubble-element .message {
        max-width: 95%;
    }
    
    .bubble-element .token-counter {
        font-size: 10px;
        margin-left: 8px;
        padding: 1px 6px;
    }
    
    .bubble-element .chat-title {
        font-size: 14px;
    }
    
    .bubble-element .toast {
        min-width: 250px;
    }
}

/* Loading States */
.bubble-element .loading {
    opacity: 0.6;
    pointer-events: none;
}

.bubble-element .spinning {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
</style>

<script>
// Bubble Chat AI Support - JavaScript Implementation
class BubbleChatAI {
    constructor(instance, properties) {
        this.instance = instance;
        this.properties = properties;
        this.messages = [];
        this.documents = [];
        this.isTyping = false;
        this.sessionTokens = 0;
        this.totalTokensUsed = 0;
        this.maxTokens = properties.max_tokens || 500;
        
        // Configuration
        this.config = {
            OPENAI_BASE_URL: 'https://api.openai.com/v1/chat/completions',
            MODEL: 'gpt-3.5-turbo',
            TEMPERATURE: 0.7,
            SYSTEM_PROMPT: `Eres un asistente de IA especializado en soporte y an√°lisis de documentos. 

CARACTER√çSTICAS:
- Hablas en espa√±ol de manera natural y profesional
- Eres √∫til, preciso y conciso en tus respuestas
- Te especializas en ayudar con documentos, hacer res√∫menes y responder preguntas
- Siempre mantienes un tono amigable pero profesional

CAPACIDADES:
- Analizar documentos subidos por el usuario
- Crear res√∫menes ejecutivos y detallados
- Responder preguntas espec√≠ficas sobre el contenido
- Extraer informaci√≥n clave de los documentos
- Dar consejos sobre organizaci√≥n de informaci√≥n

LIMITACIONES:
- Solo trabajas con documentos que el usuario haya subido
- No tienes acceso a internet ni informaci√≥n externa
- Si no tienes documentos cargados, sugiere amablemente subirlos`
        };
        
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.showWelcomeMessage();
        this.updateTokenCounter();
    }
    
    bindEvents() {
        const id = this.instance.data.id;
        const chatInput = document.getElementById(`chatInput-${id}`);
        const sendButton = document.getElementById(`sendButton-${id}`);
        const charCount = document.getElementById(`charCount-${id}`);
        const uploadBtn = document.getElementById(`uploadBtn-${id}`);
        const fileInput = document.getElementById(`fileInput-${id}`);
        const togglePanel = document.getElementById(`togglePanel-${id}`);
        
        if (chatInput) {
            chatInput.addEventListener('input', (e) => {
                this.updateCharCount(e.target.value.length);
                this.adjustTextareaHeight(e.target);
            });
            
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
        }
        
        if (sendButton) {
            sendButton.addEventListener('click', () => this.sendMessage());
        }
        
        if (uploadBtn && fileInput) {
            uploadBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
        }
        
        if (togglePanel) {
            togglePanel.addEventListener('click', () => this.toggleDocumentPanel());
        }
        
        // Chat controls
        const minimizeBtn = this.instance.canvas.find('.btn-minimize');
        const closeBtn = this.instance.canvas.find('.btn-close');
        
        minimizeBtn.on('click', () => this.minimizeChat());
        closeBtn.on('click', () => this.closeChat());
    }
    
    showWelcomeMessage() {
        const welcomeMsg = this.properties.welcome_message || 
            '¬°Hola! Soy tu asistente IA. Puedo ayudarte con documentos, responder preguntas y hacer res√∫menes. ¬øEn qu√© puedo ayudarte hoy?';
        this.addMessage(welcomeMsg, 'ai');
    }
    
    updateCharCount(length) {
        const id = this.instance.data.id;
        const charCount = document.getElementById(`charCount-${id}`);
        if (charCount) {
            charCount.textContent = length;
            
            if (length > 400) {
                charCount.style.color = '#f56565';
            } else if (length > 300) {
                charCount.style.color = '#ed8936';
            } else {
                charCount.style.color = '#718096';
            }
        }
    }
    
    adjustTextareaHeight(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    async sendMessage() {
        const id = this.instance.data.id;
        const chatInput = document.getElementById(`chatInput-${id}`);
        const message = chatInput.value.trim();
        
        if (!message || this.isTyping) return;
        
        // Add user message
        this.addMessage(message, 'user');
        chatInput.value = '';
        this.updateCharCount(0);
        this.adjustTextareaHeight(chatInput);
        
        // Show typing indicator
        this.showTypingIndicator();
        
        try {
            await this.processAIResponse(message);
        } catch (error) {
            this.showToast('Error procesando mensaje: ' + error.message, 'error');
            this.hideTypingIndicator();
        }
    }
    
    addMessage(text, sender, timestamp = null) {
        const id = this.instance.data.id;
        const chatMessages = document.getElementById(`chatMessages-${id}`);
        if (!chatMessages) return;
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${sender}-message`;
        
        const avatar = sender === 'user' ? 'üë§' : 'ü§ñ';
        const time = timestamp || this.formatTime(new Date());
        
        messageDiv.innerHTML = `
            <div class="message-avatar">${avatar}</div>
            <div class="message-content">
                <div class="message-text">${this.formatMessageText(text)}</div>
                <div class="message-time">${time}</div>
            </div>
        `;
        
        chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
        
        // Store message
        this.messages.push({
            text,
            sender,
            timestamp: timestamp || Date.now()
        });
    }
    
    formatMessageText(text) {
        return text
            .replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>') // Bold
            .replace(/\\*(.*?)\\*/g, '<em>$1</em>') // Italic
            .replace(/`(.*?)`/g, '<code>$1</code>') // Code
            .replace(/\\n/g, '<br>'); // Line breaks
    }
    
    formatTime(date) {
        return date.toLocaleTimeString('es-ES', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
    }
    
    showTypingIndicator() {
        const id = this.instance.data.id;
        const chatMessages = document.getElementById(`chatMessages-${id}`);
        if (!chatMessages || document.querySelector('.typing-indicator')) return;
        
        const typingDiv = document.createElement('div');
        typingDiv.className = 'typing-indicator';
        typingDiv.innerHTML = `
            <div class="message-avatar">ü§ñ</div>
            <div class="message-content">
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            </div>
        `;
        
        chatMessages.appendChild(typingDiv);
        
        // Animate in
        setTimeout(() => typingDiv.classList.add('show'), 100);
        
        this.isTyping = true;
        this.scrollToBottom();
    }
    
    hideTypingIndicator() {
        const typingIndicator = document.querySelector('.typing-indicator');
        if (typingIndicator) {
            typingIndicator.remove();
        }
        this.isTyping = false;
    }
    
    async processAIResponse(userMessage) {
        // Simulate AI processing time
        await this.delay(1500 + Math.random() * 1000);
        
        const response = await this.generateAIResponse(userMessage);
        
        this.hideTypingIndicator();
        this.addMessage(response, 'ai');
    }
    
    async generateAIResponse(message) {
        if (!this.properties.openai_api_key) {
            return 'Por favor, configura tu API key de OpenAI en las propiedades del elemento para que pueda responder.';
        }
        
        try {
            // Prepare context with document information
            let contextInfo = '';
            if (this.documents.length > 0) {
                contextInfo = `\\n\\nDOCUMENTOS DISPONIBLES:\\n`;
                this.documents.forEach(doc => {
                    contextInfo += `- ${doc.name}: ${doc.content.substring(0, 500)}...\\n`;
                });
                contextInfo += `\\nTotal de documentos: ${this.documents.length}`;
            }
            
            // Prepare messages array for OpenAI
            const messages = [
                {
                    role: 'system',
                    content: this.config.SYSTEM_PROMPT + contextInfo
                },
                {
                    role: 'user',
                    content: message
                }
            ];
            
            // Add recent conversation context (last 4 messages)
            const recentMessages = this.messages.slice(-4);
            const conversationContext = recentMessages.map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'assistant',
                content: msg.text
            }));
            
            // Insert conversation context before current message
            messages.splice(1, 0, ...conversationContext);
            
            // Make API call to OpenAI
            const response = await fetch(this.config.OPENAI_BASE_URL, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.properties.openai_api_key}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: this.config.MODEL,
                    messages: messages,
                    max_tokens: this.maxTokens,
                    temperature: this.config.TEMPERATURE,
                    presence_penalty: 0.1,
                    frequency_penalty: 0.1
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API Error: ${errorData.error?.message || 'Unknown error'}`);
            }
            
            const data = await response.json();
            
            if (!data.choices || data.choices.length === 0) {
                throw new Error('No response from AI');
            }
            
            // Update token counter if the API provides usage info
            if (data.usage) {
                this.sessionTokens += data.usage.total_tokens;
                this.totalTokensUsed += data.usage.total_tokens;
                this.updateTokenCounter(data.usage.total_tokens);
            }
            
            return data.choices[0].message.content.trim();
            
        } catch (error) {
            console.error('Error calling OpenAI API:', error);
            
            // Fallback to simulated responses if API fails
            return this.getFallbackResponse(message);
        }
    }
    
    getFallbackResponse(message) {
        const lowerMessage = message.toLowerCase();
        
        // Document-related queries
        if (lowerMessage.includes('documento') || lowerMessage.includes('archivo')) {
            if (this.documents.length === 0) {
                return 'No tienes documentos cargados a√∫n. Puedes subir documentos usando el bot√≥n üìé y as√≠ podr√© ayudarte mejor con informaci√≥n espec√≠fica.';
            } else {
                return `Tienes ${this.documents.length} documento(s) cargado(s). Puedo ayudarte con preguntas espec√≠ficas sobre su contenido, hacer res√∫menes o extraer informaci√≥n clave.`;
            }
        }
        
        // Fallback message
        return 'Disculpa, hay un problema temporal con la IA. Por favor intenta de nuevo en un momento. Mientras tanto, puedes subir documentos para que pueda ayudarte mejor cuando se resuelva el problema.';
    }
    
    updateTokenCounter(tokensUsed = 0) {
        const id = this.instance.data.id;
        const tokenCounter = document.getElementById(`tokenCounter-${id}`);
        if (!tokenCounter) return;
        
        // Format number with thousand separators
        const formatNumber = (num) => {
            return num.toLocaleString('es-ES');
        };
        
        if (tokensUsed > 0) {
            // Show tokens of this query + total
            const tokensText = this.sessionTokens < 1000 
                ? `${formatNumber(this.sessionTokens)} tokens`
                : `${formatNumber(Math.round(this.sessionTokens / 100) / 10)}k tokens`;
            
            tokenCounter.textContent = tokensText;
            
            // Subtle animation when updating
            tokenCounter.style.transform = 'scale(1.1)';
            setTimeout(() => {
                tokenCounter.style.transform = 'scale(1)';
            }, 200);
        } else {
            tokenCounter.textContent = '0 tokens';
        }
    }
    
    async handleFileUpload(event) {
        const files = Array.from(event.target.files);
        
        for (const file of files) {
            if (this.validateFile(file)) {
                await this.processDocument(file);
            }
        }
        
        // Clear input
        event.target.value = '';
    }
    
    validateFile(file) {
        const maxSize = 10 * 1024 * 1024; // 10MB
        const allowedTypes = ['.txt', '.pdf', '.docx', '.md'];
        
        if (file.size > maxSize) {
            this.showToast(`Archivo "${file.name}" muy grande. M√°ximo 10MB.`, 'error');
            return false;
        }
        
        const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
        if (!allowedTypes.includes(fileExtension)) {
            this.showToast(`Tipo de archivo "${fileExtension}" no soportado.`, 'error');
            return false;
        }
        
        return true;
    }
    
    async processDocument(file) {
        try {
            this.showToast(`Procesando "${file.name}"...`, 'info');
            
            // Simulate document processing
            await this.delay(2000);
            
            const document = {
                id: Date.now() + Math.random(),
                name: file.name,
                size: file.size,
                type: file.type,
                uploadedAt: Date.now(),
                content: await this.extractTextContent(file),
                processed: true
            };
            
            this.documents.push(document);
            this.updateDocumentsList();
            
            this.showToast(`"${file.name}" procesado correctamente!`, 'success');
            
            // Auto-response about uploaded document
            setTimeout(() => {
                this.addMessage(`He procesado el documento "${file.name}". Ahora puedes hacerme preguntas espec√≠ficas sobre su contenido o pedirme que haga un resumen. ¬øEn qu√© te gustar√≠a que te ayude?`, 'ai');
            }, 1000);
            
        } catch (error) {
            this.showToast(`Error procesando "${file.name}": ${error.message}`, 'error');
        }
    }
    
    async extractTextContent(file) {
        // Mock text extraction - in real implementation would use proper parsers
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                // Simulate extracted text
                const mockContent = `Contenido extra√≠do del archivo ${file.name}. 

Este es un texto de ejemplo que representar√≠a el contenido real del documento una vez procesado por el sistema de extracci√≥n de texto.

El documento contiene informaci√≥n relevante que puede ser analizada y resumida por la IA para responder preguntas espec√≠ficas del usuario.`;
                
                resolve(mockContent);
            };
            reader.readAsText(file);
        });
    }
    
    updateDocumentsList() {
        const id = this.instance.data.id;
        const documentList = document.getElementById(`documentList-${id}`);
        if (!documentList) return;
        
        if (this.documents.length === 0) {
            documentList.innerHTML = `
                <div class="empty-state">
                    <p>No hay documentos cargados.</p>
                    <p>Sube documentos para que la IA pueda ayudarte mejor.</p>
                </div>
            `;
            return;
        }
        
        documentList.innerHTML = this.documents.map(doc => `
            <div class="document-item" data-id="${doc.id}">
                <div class="document-info">
                    <div class="document-icon">${this.getFileIcon(doc.name)}</div>
                    <div class="document-details">
                        <h4>${doc.name}</h4>
                        <p>${this.formatFileSize(doc.size)} ‚Ä¢ ${this.formatTime(new Date(doc.uploadedAt))}</p>
                    </div>
                </div>
                <div class="document-actions">
                    <button class="action-btn" onclick="window.bubbleChatAI_${id}.summarizeDocument('${doc.id}')" title="Resumir">üìÑ</button>
                    <button class="action-btn" onclick="window.bubbleChatAI_${id}.removeDocument('${doc.id}')" title="Eliminar">üóëÔ∏è</button>
                </div>
            </div>
        `).join('');
        
        // Store reference globally for onclick handlers
        window[`bubbleChatAI_${id}`] = this;
    }
    
    getFileIcon(filename) {
        const extension = filename.split('.').pop().toLowerCase();
        const icons = {
            'pdf': 'üìï',
            'docx': 'üìò',
            'doc': 'üìò',
            'txt': 'üìÑ',
            'md': 'üìù'
        };
        return icons[extension] || 'üìÑ';
    }
    
    formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }
    
    async summarizeDocument(docId) {
        const doc = this.documents.find(d => d.id == docId);
        if (!doc) return;
        
        this.showTypingIndicator();
        
        try {
            const prompt = `Por favor, crea un resumen detallado del siguiente documento "${doc.name}":\\n\\n${doc.content}`;
            const summary = await this.generateAIResponse(prompt);
            
            this.hideTypingIndicator();
            this.addMessage(`üìÑ **Resumen de "${doc.name}":**\\n\\n${summary}`, 'ai');
        } catch (error) {
            this.hideTypingIndicator();
            this.addMessage(`No pude generar el resumen de "${doc.name}". ${error.message}`, 'ai');
        }
    }
    
    removeDocument(docId) {
        this.documents = this.documents.filter(d => d.id != docId);
        this.updateDocumentsList();
        this.showToast('Documento eliminado', 'info');
    }
    
    toggleDocumentPanel() {
        const id = this.instance.data.id;
        const panelContent = this.instance.canvas.find('.panel-content');
        const toggleButton = document.getElementById(`togglePanel-${id}`);
        
        panelContent.toggleClass('collapsed');
        if (toggleButton) {
            toggleButton.classList.toggle('collapsed');
        }
    }
    
    minimizeChat() {
        const chatContainer = this.instance.canvas.find('.chat-container');
        chatContainer.css({
            'transform': 'scale(0.8)',
            'opacity': '0.5'
        });
        setTimeout(() => {
            chatContainer.hide();
        }, 300);
    }
    
    closeChat() {
        if (confirm('¬øSeguro que quieres cerrar el chat? Se perder√° la conversaci√≥n actual.')) {
            this.instance.canvas.find('.chat-container').hide();
        }
    }
    
    scrollToBottom() {
        const id = this.instance.data.id;
        const chatMessages = document.getElementById(`chatMessages-${id}`);
        if (chatMessages) {
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }
    }
    
    showToast(message, type = 'info') {
        const id = this.instance.data.id;
        const toastContainer = document.getElementById(`toastContainer-${id}`);
        if (!toastContainer) return;
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        toastContainer.appendChild(toast);
        
        // Auto remove after 4 seconds
        setTimeout(() => {
            toast.style.animation = 'slideIn 0.3s ease-out reverse';
            setTimeout(() => toast.remove(), 300);
        }, 4000);
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    updateProperties(properties) {
        this.properties = properties;
        this.maxTokens = properties.max_tokens || 500;
        
        // Update welcome message if changed
        if (properties.welcome_message) {
            // Could refresh welcome message here if needed
        }
    }
    
    destroy() {
        // Clean up event listeners and global references
        const id = this.instance.data.id;
        if (window[`bubbleChatAI_${id}`]) {
            delete window[`bubbleChatAI_${id}`];
        }
        
        // Clear any timeouts or intervals if they exist
        // Additional cleanup code here
    }
}
</script>